# shell终端crontab定时任务

在`Linux`系统的实际使用中，可能会经常碰到让系统在某个特定时间执行某些任务的情况，比如定时采集服务器的状态信息、负载状况；定时执行某些任务/脚本来对远端进行数据采集等。这里将介绍下`crontab`的配置参数以及一些使用实例。

## crontab配置文件

`Linux`下的任务调度分为两类：系统任务调度和用户任务调度。`Linux`系统任务是由 `cron (crond)` 这个系统服务来控制的，这个系统服务是默认启动的。用户自己设置的计划任务则使用`crontab`命令。

```bash
cat /etc/crontab
```

配置文件可以看到如下解释：

```bash
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
HOME=/
# For details see man 4 crontabs
# Example of job definition:
# .---------------- minute (0 - 59)
# | .------------- hour (0 - 23)
# | | .---------- day of month (1 - 31)
# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...
# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# | | | | |
# * * * * * user-name command to be executed
```

前四行是用来配置`crond`任务运行的环境变量

> 第一行`SHELL`变量指定了系统要使用哪个`shell`，这里是`bash`
>
> 第二行`PATH`变量指定了系统执行命令的路径
>
> 第三行`MAILTO`变量指定了`crond`的任务执行信息将通过电子邮件发送给`root`用户，如果`MAILTO`变量的值为空，则表示不发送任务执行信息给用户
>
> 第四行的`HOME`变量指定了在执行命令或者脚本时使用的主目录。

用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用`crontab`工具来定制自己的计划任务。所有用户定义的`crontab`文件都被保存在 `/var/spool/cron`目录中。其文件名与用户名一致。

## crontab文件含义

用户所建立的`crontab`文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：

```
minute hour day month week command
```

![img](https://raw.githubusercontent.com/gdcgx/picture/main/img/202110252013802.png)

> 在以上各个字段中，还可以使用以下特殊字符：
>
> `*`代表所有的取值范围内的数字，如月份字段为`*`，则表示1到12个月；
>
> `/`代表每一定时间间隔的意思，如分钟字段为`*/10`，表示每10分钟执行1次。
>
> `-`代表从某个区间范围，是闭区间。如`2-5`表示`2,3,4,5`，小时字段中`0-23/2`表示在`0~23`点范围内每2个小时执行一次。
>
> `,`分散的数字（不一定连续），如`1,2,3,4,7,9`。
>
> 注：由于各个地方每周第一天不一样，因此`Sunday=0`（第一天）或`Sunday=7`（最后1天）。

## crontab命令详解

格式:

```
crontab [-u user] file
crontab [ -u user ] [ -i ] { -e | -l | -r }
```

> ` -u user`：用于设定某个用户的`crontab`服务；
>
> `file`: file为命令文件名，表示将`file`作为`crontab`的任务列表文件并载入`crontab`；
>
> ` -e`：编辑某个用户的`crontab`文件内容，如不指定用户则表示当前用户；
>
> `-l`：显示某个用户的`crontab`文件内容，如不指定用户则表示当前用户；可以使用这种方法在$ H O M E目录中对crontab文件做一备份：
>
> ```
> $ crontab -l > $HOME/mycron
> ```
>
> `-r`：从`/var/spool/cron`目录中删除某个用户的`crontab`文件。
>
> `-i`：在删除用户的`crontab`文件时给确认提示。

## crontab注意点

> `crontab`有2种编辑方式：直接编辑`/etc/crontab`文件与`crontab –e`，其中`/etc/crontab`里的计划任务是系统中的计划任务，而用户的计划任务需要通过`crontab –e`来编辑；
>
> 每次编辑完某个用户的`cron`设置后，`cron`自动在`/var/spool/cron`下生成一个与此用户同名的文件，此用户的`cron`信息都记录在这个文件中，这个文件是不可以直接编辑的，只可以用`crontab -e` 来编辑。
>
> `crontab`中的`command`尽量使用绝对路径，否则会经常因为路径错误导致任务无法执行。
>
> 新创建的`cron job`不会马上执行，至少要等2分钟才能执行，可从起`cron`来立即执行。
>
> `%`在`crontab`文件中表示"换行"，因此假如脚本或命令含有`%`,需要使用`\%`来进行转义。

## crontab配置实例

每一分钟执行一次`command`（因`cron`默认每`1`分钟扫描一次，因此全为`*`即可）

```
*    *    *    *    *  command
```

每小时的第3和第15分钟执行`command`

```
3,15   *    *    *    *  command
```

每天上午8-11点的第3和15分钟执行`command`：

```
3,15  8-11  *  *  *  command
```

每隔2天的上午8-11点的第3和15分钟执行`command`：

```
3,15  8-11  */2  *   *  command
```

每个星期一的上午8点到11点的第3和第15分钟执行`command`

```
3,15  8-11   *   *  1 command
```

每晚的21:30重启`smb`

```
30  21   *   *  *  /etc/init.d/smb restart
```

每月1、10、22日的4 : 45重启`smb`

```
45  4  1,10,22  *  *  /etc/init.d/smb restart
```

每周六、周日的1 : 10重启`smb`

```
10  1  *  *  6,0  /etc/init.d/smb restart
```

每天18 : 00至23 : 00之间每隔30分钟重启`smb`

```
0,30  18-23  *  *  *  /etc/init.d/smb restart
```

每一小时重启`smb`

```
*  */1  *  *  *  /etc/init.d/smb restart
```

晚上11点到早上7点之间，每隔一小时重启`smb`

```
*  23-7/1  *   *   *  /etc/init.d/smb restart
```

每月的4号与每周一到周三的11点重启`smb`

```
0  11  4  *  mon-wed  /etc/init.d/smb restart
```

每小时执行`/etc/cron.hourly`目录内的脚本

```
0  1   *   *   *     root run-parts /etc/cron.hourly
```

## 关于 >/dev/null 2>&1 的解释：

> 0表示键盘输入
>
> 1表示标准输出
>
> 2表示错误输出

我们首先创建`test.sh`脚本如下：

```
#! /bin/sh
echo "hello, everybody, now is " `date`
date >> test.txt
```

然后添加作业

```
* * * * * /home/oracle/test.sh >/home/oracle/log.txt & 默认值为1，即和下面命令一致
* * * * * /home/oracle/test.sh 1>/home/oracle/log.txt &
* * * * * /home/oracle/test.sh 2>/home/oracle/log.txt &
* * * * * /home/oracle/test.sh 2>/home/oracle/log.txt 2>&1 &
```

`1,2`将`tesh.sh`命令输出重定向到`log.txt`, 即输出内容不打印到屏幕上，而是输出到`log.txt`文件中。如果你需要追加而不是覆盖，可以用 `>>`代替`>`

`2>&1` 是将错误输出重定向到标准输出。 然后将标准输入重定向到文件`log.txt`。

`&1` 表示的是文件描述1，表示标准输出，如果这里少了`&`就成了数字1，就表示重定向到文件1。

### shell重定向介绍

就像我们平时写的程序一样，一段程序会处理外部的输入，然后将运算结果输出到指定的位置。在交互式的程序中，输入来自用户的键盘和鼠标，结果输出到用户的屏幕，甚至播放设备中。而对于某些后台运行的程序，输入可能来自于外部的一些文件，运算的结果通常又写到其他的文件中。而且程序在运行的过程中，会有一些关键性的信息，比如异常堆栈，外部接口调用情况等，这些都会统统写到日志文件里。

`shell`脚本也一样，但是我们一般在使用`shell`命令的时候，更多地还是通过键盘输入，然后在屏幕上查看命令的执行结果。如果某些情况下，我们需要将`shell`命令的执行结果存储到文件中，那么我们就需要使用输入输出的重定向功能。

### 文件描述符

当执行`shell`命令时，会默认打开3个文件，每个文件有对应的文件描述符来方便我们使用：

| 类型                        | 文件描述符 | 默认情况               | 对应文件句柄位置 |
| --------------------------- | ---------- | ---------------------- | ---------------- |
| 标准输入（standard input）  | 0          | 从键盘获得输入         | /proc/self/fd/0  |
| 标准输出（standard output） | 1          | 输出到屏幕（即控制台） | /proc/self/fd/1  |
| 错误输出（error output）    | 2          | 输出到屏幕（即控制台） | /proc/self/fd/2  |

所以我们平时在执行`shell`命令中，都默认是从键盘获得输入，并且将结果输出到控制台上。但是我们可以通过更改文件描述符默认的指向，从而实现输入输出的重定向。比如我们将1指向文件，那么标准的输出就会输出到文件中。

###  输出重定向

输出重定向的使用方式很简单，基本的一些命令如下：

| 命令                | 介绍                       |
| ------------------- | -------------------------- |
| command >filename   | 把标准输出重定向到新文件中 |
| command 1>filename  | 同上                       |
| command >>filename  | 把标准输出追加到文件中     |
| command 1>>filename | 同上                       |
| command 2>filename  | 把标准错误重定向到新文件中 |
| command 2>>filename | 把标准错误追加到新文件中   |

我们使用`>`或者`>>`对输出进行重定向。符号的左边表示文件描述符，如果没有的话表示1，也就是标准输出，符号的右边可以是一个文件，也可以是一个输出设备。当使用`>`时，会判断右边的文件存不存在，如果存在的话就先删除，然后创建一个新的文件，不存在的话则直接创建。但是当使用`>>`进行追加时，则不会删除原来已经存在的文件。

### 输入重定向

在理解了输出重定向之后，理解输入重定向就会容易得多。对输入重定向的基本命令如下：

| 命令                | 介绍                                      |
| ------------------- | ----------------------------------------- |
| command <filename   | 以filename文件作为标准输入                |
| command 0<filename  | 同上                                      |
| command <<delimiter | 从标准输入中读入，直到遇到delimiter分隔符 |

我们使用`<`对输入做重定向，如果符号左边没有写值，那么默认就是0。

###  重定向绑定

####  **>/dev/null**

这条命令的作用是将标准输出1重定向到`/dev/null`中。 `/dev/null`代表linux的空设备文件，所有往这个文件里面写入的内容都会丢失，俗称“黑洞”。那么执行了`>/dev/null`之后，标准输出就会不再存在，没有任何地方能够找到输出的内容。

#### **2>&1**

这条命令用到了重定向绑定，采用&可以将两个输出绑定在一起。这条命令的作用是错误输出将和标准输出同用一个文件描述符，说人话就是错误输出将会和标准输出输出到同一个地方。

`linux`在执行`shell`命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令，所以`>/dev/null 2>&1`的作用就是让标准输出重定向到`/dev/null`中（丢弃标准输出），然后错误输出由于重用了标准输出的描述符，所以错误输出也被定向到了`/dev/null`中，错误输出同样也被丢弃了。执行了这条命令之后，该条`shell`命令将不会输出任何信息到控制台，也不会有任何信息输出到文件中。

#### **>/dev/null 2>&1  VS  2>&1 >/dev/null**

乍眼看这两条命令貌似是等同的，但其实大为不同。刚才提到了，`linux`在执行`shell`命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令。那么我们同样从左到右地来分析`2>&1 >/dev/null`：

`2>&1`，将错误输出绑定到标准输出上。由于此时的标准输出是默认值，也就是输出到屏幕，所以错误输出会输出到屏幕。
`>/dev/null`，将标准输出1重定向到`/dev/null`中。我们用一个表格来更好地说明这两条命令的区别： 

| 命令            | 标准输出 | 错误输出 |
| --------------- | -------- | -------- |
| >/dev/null 2>&1 | 丢弃     | 丢弃     |
| 2>&1 >/dev/null | 丢弃     | 屏幕     |

## crond服务

安装`crontab`：

```
yum install crontabs
```

服务操作说明：

```
/sbin/service crond start //启动服务

/sbin/service crond stop //关闭服务

/sbin/service crond restart //重启服务

/sbin/service crond reload //重新载入配置

/sbin/service crond status //启动服务
```

查看`crontab`服务是否已设置为开机启动，执行命令：

```
ntsysv
```

加入开机自动启动：

```
chkconfig –level 35 crond on
```

## 使用注意事项

### 注意环境变量问题

有时我们创建了一个`crontab`，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在`crontab`文件中没有配置环境变量引起的。

在 `crontab`文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前`shell`环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在`crontab`文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。

不要假定`cron`知道所需要的特殊环境，它其实并不知道。所以你要保证在`shelll`脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：

> 1）脚本中涉及文件路径时写全局路径；
>
> 2）脚本执行要用到`java`或其他环境变量时，通过`source`命令引入环境变量，如：
>
> ```
> cat start_cbp.sh
> 
> \#!/bin/sh
> 
> source /etc/profile
> 
> export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf
> 
> /usr/local/jboss-4.0.5/bin/run.sh -c mev &
> ```
>
> 3）当手动执行脚本`OK`，但是`crontab`死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在`crontab`中直接引入环境变量解决问题。如：
>
> ```
> 0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh
> ```
>
> 注意清理系统用户的邮件日志
> 每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。
>
> 例如，可以在`crontab`文件中设置如下形式，忽略日志输出：
>
> ```
> 0 */3 * * * /usr/local/apache2/apachectl restart >/dev/null 2>&1
> ```
>
> `/dev/null 2>&1`表示先将标准输出重定向到`/dev/null`，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了`/dev/null`，因此标准错误也会重定向到`/dev/null`，这样日志输出问题就解决了。

### 系统级任务调度与用户级任务调度

系 统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么 做），但是反过来却不行，`root`用户的任务调度操作可以通过`“crontab –uroot –e”`来设置，也可以将调度任务直接写入`/etc /crontab`文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到`/etc/crontab`文件，即使在`root`用户下创建一个 定时重启系统的任务也是无效的。

### 其他注意事项

尽量所有的文件都采用完全路径方式，避免使用相对路径。

新创建的`cron job`，不会马上执行，至少要过2分钟才执行。如果重启`cron`则马上执行。

当`crontab`突然失效时，可以尝试`/etc/init.d/crond restart`解决问题。或者查看日志看某个`job`有没有执行`/`报错`tail -f /var/log/cron`。

千万别乱运行`crontab -r`。它从`Crontab`目录（`/var/spool/cron`）中删除用户的`Crontab`文件。删除了该用户的所有`crontab`都没了。

在`crontab`中`%`是有特殊含义的，表示换行的意思。如果要用的话必须进行转义`\%`，如经常用的`date ‘+%Y%m%d’`在`crontab`里是不会执行的，应该换成`date ‘+\%Y\%m\%d’`。

