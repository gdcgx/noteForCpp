# `inline` 内联

函数调用在执行时，首先要在栈中为形参和局部变量分配存储空间，然后还要将实参的值复制给形参，接下来还要将函数的返回地址（该地址指明了函数执行结束后，程序应该回到哪里继续执行）放入栈中，最后才跳转到函数内部执行。这个过程是要耗费时间的。

另外，函数执行 `return` 语句返回时，需要从栈中回收形参和局部变量占用的存储空间，然后从栈中取出返回地址，再跳转到该地址继续执行，这个过程也要耗费时间。

总之，使用函数调用语句和直接把函数中的代码重新抄写一遍相比，节省了人力，但是带来了程序运行时间上的额外开销。

一般情况下，这个开销可以忽略不计。但是，如果一个函数内部没有几条语句，执行时间本来就非常短，那么这个函数调用产生的额外开销和函数本身执行的时间相比，就显得不能忽略了。假如这样的函数在一个循环中被上千万次地执行，函数调用导致的时间开销可能就会使得程序运行明显变慢。

作为特别注重程序执行效率，适合编写底层系统软件的高级程序设计语言，`C++` 用 `inline` 关键字较好地解决了函数调用开销的问题。

## 1、`inline` 的定义

`inline` 是 `C++` 关键字，在函数声明或定义中，函数返回类型前加上关键字 `inline`，即可以把函数指定为 **内联函数**。

内联函数和普通函数的区别在于：

> 当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。

有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。很显然，使用内联函数会使最终可执行程序的体积增加。以时间换取空间，或增加空间消耗来节省时间，这是计算机学科中常用的方法。

在 `C++` 中，可以在定义函数时，在返回值类型前面加上 `inline` 关键字。如：

```c++
#include <iostream>

inline int Max (int a, int b)
{
    if(a >b)
        return a;
    return b;
}

int main(){
    std::cout << Max(1,2) << std::endl;
}
```

上面的例子就是标准的内联函数的用法，使用 `inline` 修饰带来的好处我们表面看不出来，其实，在内部的工作就是在每个 `for` 循环的内部任何调用 `Max` 的地方都换成了 `if(a>b) return a; returnb;`，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。

## 2、预定义

> `inline` 定义的类的内联函数，函数的代码被放入符号表中，在使用时直接进行替换（像宏一样展开），没有了调用的开销，效率也很高。
>
> 很明显，类的内联函数也是一个真正的函数，编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。
>
> `inline`可以作为某个类的成员函数，当然就可以在其中使用所在类的保护成员及私有成员。

## 3、`inline` 对比 宏

在 `C` 程序中，一般使用宏来提高代码的执行效率，宏本身不是函数，但是使用起来像是函数。编译预处理器用拷贝宏代码的方式取代函数调用，省去了参数压栈、生成汇编语言的 `CALL` 调用、返回参数、执行 `return` 等过程，从而提高了速度。使用宏代码最大的缺点是容易出错，预处理器在拷贝宏代码时常常产生意想不到的边际效应。例如：

```c++
#define MAX(a,b) (a)>(b)?(a):(b)
```

语句：

```c++
result = MAX(i,j) + 2;
```

将被预处理器扩展为：

```
result = (i)>(j)?(i):(j)+2;
```

由了运算符 "`+"` 比运算符 `" ？ ："` 的优先级高，所以上述语句并不等价于期望的：

```c++
result=( (i) > (j) ？ (i) : (j) ) + 2;
```

如果把宏代码改写为：

```c++
#define MAX(a,b) ((a)>(b)?(a):(b))
```

则可以解决由优先级引起的错误。但是即使使用修改后的宏代码也不是万无一失的，例如语句：

```c++
result = MAX(i++,j);
```

将被预处理器解释为：

```c++
result = (i++)>(j)？(i++):(j);	∥在同一个表达式中i被两次求值
```

宏的另一个缺点就是不可调试，但是内联函致是可以调试的。内联函数不是也像宏一样进行代码展开吗？怎么能够调试呢？

其实内联函数的 “可调试” 不是说它展开后还能调试，而是在程序的调试 `(Debug)` 版本里它根本就没有真正内联，编译器像普通函数那样为它生成含有调试信息的可执行代码。在程序的发行 `(Release)` 版本里，编译器才会实施真正的内联。有的编译器可以设置函数内联开关，例如 `Visual C++`。

对于 `C++` 而言，使用宏代码还有另一种缺点：

> 无法操作类的私有数据成员。

让我们看看 `C++` 的“函数内联”是如何工作的：

> 对任何内联函数，编译器在符号表里放入函数的声明，包括名字、参数类型、返回值类型（符号表是编译器用来收集和保存字面常量和某些符号常量的方)。如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样)。如果正确，内联函数的代码就会直接替换函数调用语句，于是省去了函数调用的开销。这个过程与预处理器有显著的不同，因为预处理器不能进行类型安全检查和自动类型转换。假如内联函数是成员函数，对象的地址`(this)`会被放在合适的地方，这也是预处理器办不到的。

`C++` 语言的函数内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作类的数据成员，所以在 `C++` 程序中应该尽量用内联函数来取代宏代码，断言`assert` 恐怕是唯一的例外。`assert` 是仅在 `Debug` 版本中起作用的宏，它用于检查“不应该”发生的情况。为了不在程序的 `Debug` 版本和 `Release` 版本之间引起差别，`assert` 不应该产生任何副作用。如果 `assert` 是函数，由于函数调用会引起内存、代码的变动，那么将导致 `Debug` 版本与 `Release` 版本存在某些差异，这并非我们所期望的。所以 `assert` 不是函数，而是宏。

内联函数的另一个优点就是：

> 函数被内联后，编译器就可以通过上下文相关的优化技术对结果代码执行更深入的优化，而这种优化在普通函数体内是无法单独进行的，因为一旦进入函数体内它也就脱离了调用环境的上下文

## 4、`inline` 使用限制

### 慎用 `inline`

内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着"内联"这个关键字吗？ 

内联是以**代码膨胀（复制）**为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。 

如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。

以下情况不宜使用内联： 

> 如果函数体内的代码**比较长**，使用内联将导致**内存消耗代价较高**。 
>
> 如果函数体内出现 **循环(for、switch、while)** ，那么执行函数体内代码的时间要比函数调用的开销大。类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如"偷偷地"执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 `inline` 不应该出现在函数的声明中）。

### 建议 `inline` 函数的定义放在头文件中

因为内联函数要在调用点展开，所以编译器必须 **随处可见** 内联函数的 **定义**，要不然就成了非内联函数的调用了。所以，这要求每个调用了内联函数的文件都出现了该内联函数的定义。

因此，将内联函数的 **定义放在头文件** 里实现是合适的：

> 省却为每个文件实现一次的麻烦。
>
> 因为声明跟定义要一致，如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。

### 不能对函数进行取址操作

因为内联函数会被替代成内部的实现部分，故函数体在编译时候不存在，也就不能取址。

## 5、`inline` 特性

### `inline` 仅是一个对编译器的建议

`inline` 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联。如果将一个长达1000多行的函数指定为 `inline`，编译器就会忽略这个 `inline`，将这个函数还原成普通函数。

因此，并不是说声明了内联就会内联，声明内联只是一个建议而已。

### `inline`  是一种"用于实现的关键字"

关键字 `inline` 必须与函数定义体放在一起才能使函数成为内联，仅将 `inline` 放在函数声明前面不起任何作用。

如下风格的函数 `Foo` 不能成为内联函数：

```c++
inline void Foo(int x, int y); // inline 仅与函数声明放在一起
void Foo(int x, int y){}
```

而如下风格的函数 `Foo` 则成为内联函数：

```c++
void Foo(int x, int y);
inline void Foo(int x, int y) {} // inline 与函数定义体放在一起
```

所以说，`inline` 是一种 "**用于实现的关键字**" ，而不是一种 "**用于声明的关键字**" 。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了`inline` 关键字，但我认为 **`inline`不应该出现在函数的声明中** 。这个细节虽然不会影响函数的功能，但是体现了高质量 `C++/C` 程序设计风格的一个基本原则：**声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。**

## 6、类中的成员函数与 `inline`

定义在类中的成员函数默认都是内联的，编译器会自动将行数少的函数转成 `inline` 函数。如果在类定义时就在类内给出函数定义，那当然最好。如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 `inline`，否则就认为不是内联的。

```c++
class A {    
public:
    void Foo(int x, int y) {} // 自动地成为内联函数 
}
```

将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：

```c++
// 头文件 
class A {    
public:    
    void Foo(int x, int y);
}   
// 定义文件 
inline void A::Foo(int x, int y){}
```

## 7、内联函数与一般函数区别

> 内联含函数比一般函数在前面多一个 `inline` 修饰符。
>
> 内联函数是直接复制“镶嵌”到主函数中去的，就是将内联函数的代码直接放在内联函数的位置上，这与一般函数不同，主函数在调用一般函数的时候，是指令跳转到被调用函数的入口地址，执行完被调用函数后，指令再跳转回主函数上继续执行后面的代码；而由于内联函数是将函数的代码直接放在了函数的位置上，所以没有指令跳转，指令按顺序执行。
>
> 一般函数的代码段只有一份，放在内存中的某个位置上，当程序调用它是，指令就跳转过来；当下一次程序调用它是，指令又跳转过来；而内联函数是程序中调用几次内联函数，内联函数的代码就会复制几份放在对应的位置上
>
> 内联函数一般在头文件中定义，而一般函数在头文件中声明，在 `cpp` 中定义。



# `constexpr` 关键字

`C++11`为了提高代码执行效率做了一些改善。这种改善之一就是:生成常量表达式，允许程序利用编译时的计算能力。

常量表达式：是指值不会改变并且在编译过程就能得到计算结果的表达式。一个对象是不是常量表达式是由它的数据类型和初始值共同决定。

```c++
int staff_size = 27;//虽然初始值是字面值常量，但是它的数据类型只是普通int。
const int sz = get_size(); //虽然sz本身是常量，但是它的具体值直到运行时才能获取到所以也不是常量表达式
const int num = 50; //常量表达式
```

常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时。

需要计算一个编译时已知的常量，比如特定值的 `sin` 或 `cos` ？确实你亦可以使用库函数 `sin` 或 `cos` ，但那样必须花费运行时的开销。使用 `constexpr`，可以创建一个编译时的函数，它将计算出需要的数值，用户的电脑将不需要做这些工作。

## 1、`constexpr` 和 `const`

提到 `const` 和 `constexpr`，就需要引入常量表达式。

常量表达式是指值不会改变，并且编译过程就能得到计算结果的表达式。 => 编译阶段就能得到值，并且不能改变。

`const` 修饰对象无法修改，`constexpr`更侧重于修饰对象编译期确定且无法修改。具体区别，体现在以下两个方面：

> ### 修饰变量
>
> `const` 变量，表示一个变量无法改变，但初值并不确定，不能在编译阶段决定。比如，
>
> ```c++
> const int sz = get_size(); // 虽然sz无法改变，但get_size() 编译阶段无法确定值，也就是说sz不是常量表达式
> ```
>
> `constexpr ` 变量，编译器在编译阶段验证变量是否为一个常量表达式。
>
> `constexpr ` 侧重变量初值编译阶段确定，且无法修改。如果认定变量是一个常量表达式，就把它声明称 `constexpr` 类型。
>
> ```c++
> constexpr int mf = 20; // 字面量20是常量表达式
> constexpr int limit = mf + 1; // mf + 1是常量表达式
> constexpr int sz = size(); // 只有当size是constexpr函数时，才是正确的
> ```
>
> ### 修饰指针
>
> `const` 修饰指针分为两种情况：顶层 `const`, 底层 `const`。
> 顶层 `const` 代表指针变量自身无法修改；底层 `const` 代表指针所指对象无法修改。
>
> ```c++
> int i = 10;
> int *const p1 = &i; // 顶层const
> const int *p2 = &i; // 底层const
> 
> p1 = new int(20); // 错误，顶层const指针自身无法修改
> p2 = new int(30); // 正确，底层const指针可以修改
> *p1 = 40; // 正确，顶层const指针指向的对象可以修改
> *p2 = 40; // 错误，底层const指针指向的对象无法修改
> ```
>
> `constexpr` 修饰指针，仅对指针有效，与指针所指对象无关
>
> ```c++
> // j的定义必须放在函数体外
> int j = 30;
> 
> // 函数体内
> constexpr int *pp1 = &j; // 等价于 int constexpr *pp1 = &j;
> cout << *pp1 << endl; // 30
> *pp1 = 40;
> cout << j << endl; // 40
> pp1 = nullptr; // 错误，constexpr指针无法修改
> ```
>
> ### 修饰函数
>
> - `const` 修饰成员函数，通常称为 `const` 函数，表示该函数不会修改类的状态（即不会通过任何方式修改类数据成员）。另外，`const` 类对象，只能调用 `const` 函数，确保不会修改类的数据成员。
>
> - `constexpr` 无法修饰成员函数，只能作为函数返回值类型，表明该函数返回的是一个**编译期可确定的常量**；`constexpr` 被隐式隐式指定为**内联函数**，只能在类的声明中定义（.h文件）。
>
>   ```c++
>   // A.h
>   class A{
>   public:
>     A():curSize(10) {}
>     void setSize(int size) { size++; }
>   
>     // const函数
>     int size() const { return curSize; }  // 正确示例：不写任何数据成员
>     int size() const { curSize = 2; return curSize; }; // 错误示例： const函数不能修改任何类的数据成员
>     int size() const { setSize(); return curSize; } // 错误示例：const函数不能调用任何可能导致类的数据成员改变的函数，也就是说，如果调用自身成员函数，只能调用const函数
>     const int size() { return curSize; }  // 函数返回值为const类型：函数体可以修改数据成员，但返回类型是const，也就是调用者无法修改
>   
>     // 函数返回值为constexpr类型
>     constexpr int getMaxSize() { return INT_MAX; } // 正确示例：返回常量值
>     // 错误示例：vec.size()运行时确定，不能在编译期决定
>     constexpr int getMaxSize() 
>     {
>       std::vector<int> vec;
>       vec.push_back(1);
>       vec.push_back(2);
>       return vec.size();
>     }
>     // 正确：虽然看起来返回的是变量，但编译器可确定
>     constexpr int getMaxSize(int a, int b) 
>     {
>       return a + b;
>     }
>   
>   private:
>     int curSize;
>   }
>   
>   // A.cpp
>   // 错误示例：constexpr被隐式指定为内联函数，只能在.h 类内定义，不能在类实现文件(.cpp)中定义
>   constexpr int A::getMaxsize() 
>   {
>     return 1;
>   }
>   ```

## 2、`constexpr` 初探

为了使函数获取编译时计算的能力，必须指定 `constexpr` 关键字到这个函数。

```c++
constexpr int multiply(int x, int y){
	return x * y;
}
// 将在编译时计算
const int val = multiply( 10, 10 );
```

除了编译时计算的性能优化，`constexpr` 的另外一个优势是，它允许函数被应用在以前调用宏的所有场合。

例如，想要一个计算数组 `size` 的函数，`size` 是 `10` 的倍数。如果不用 `constexpr`，需要创建一个宏或者使用模板，因为不能用函数的返回值去声明数组的大小。但是用 `constexpr`，就可以调用一个 `constexpr` 函数去声明一个数组。

```c++
constexpr int getDefaultArraySize (int multiplier){
	return 10 * multiplier;
}
int my_array[getDefaultArraySize(3)];
int a = 4;　　//非常量表达式
getDefaultArraySize(a);　　//ok
```

`constexpr` 修饰的函数，简单的来说，如果其传入的参数可以在编译时期计算出来，那么这个函数就会产生编译时期的值。但是，传入的参数如果不能在编译时期计算出来，那么 `constexpr` 修饰的函数就和普通函数一样了。不过，我们不必因此而写两个版本，所以如果函数体适用于 `constexpr` 函数的条件，可以尽量加上 `constexpr`。

## 3、`constexpr` 修饰函数限制

一个 `constexpr` 有一些必须遵循的严格要求：

> - 函数中只能有一个`return`语句(但允许包含`typedefs`、 `using declaration && directives`、静态断言等)
> - 只能调用其它`constexpr`函数
> - 只能使用全局`constexpr`变量

注意递归并不受限制,但只允许一个返回语句，那如何实现递归呢？可以使用三元运算符`( ? : )`。例如，计算`n`的阶乘：

```c++
constexpr int factorial (int n) {  
	return n > 0 ? n * factorial( n - 1 ) : 1;
}
```

现在可以使用`factorial(2)`，编译器将在编译时计算这个值，这种方式运行更巧妙的计算，与内联截然不同，因为无法内联一个递归函数。

`constexpr` 函数可以用于初始化 `constexpr`变量，其函数的返回类型以及所有形参的类型都是字面值类型，且函数体中有且只有一条`return`语句。且`constexpr` 函数和被隐式的指定为内联函数。

```c++
//编译器在程序编译时可以验证new_sz返回的是常量表达式，所以可以用new_sz的返回值初始化constexpr变量foo
constexpr int new_sz() {return 42;}
constexpr int foo = new_sz(); //foo是一个常量表达式
```

另外我们允许 `constexpr` 函数的返回值并非一个常量：**如果实参是常量表达式，那么函数返回值也是常量表达式**

```c++
 //当scale的实参是常量表达式时，其返回值也是常量表达式 
 constexpr size_t scale(const size_t cnt){
 	return new_sz() * cnt
 } 
```

## 4、使用编译时对象

`constexpr` 修饰类的构造函数，即保证如果提供给该构造函数的参数都是 `constexpr`，那么产生的对象中的所有成员都会是 `constexpr`，该对象也就是`constexpr` 对象了，可用于各种只能使用 `constexpr` 的场合。注意，`constexpr` 构造函数必须有一个空的函数体，即所有成员变量的初始化都放到初始化列表中。
假如你有一个`Circle`类:

```c++
class Circle{
public: 
	constexpr Circle (int x,int y,int radius) : _x( x ), _y( y ), _radius( radius ) {}  
	constexpr double getArea () {    
		return _radius * _radius * 3.1415926;  
	}
private:  
	int _x;
    int _y;
    int _radius;
};
```

将构造函数和 `getArea` 声明为 `constexpr`，这样在编译期间，便能构造一个对象并能调用 `getArea` 函数获得 `area`：

```c++
constexpr Circle c( 0, 0, 10 );
constexpr double area = c.getArea();
```